/**
 * Question validation utilities
 * Ensures questions generated by AI have proper structure and synchronization
 */

import type {
    Phase1Question,
    Phase4Question,
    Phase5Question,
} from './types';

/**
 * Validation result for a single question
 */
export interface ValidationResult {
    valid: boolean;
    errors: string[];
}

/**
 * Validate a Phase 1 question (MCQ with 4 options)
 * Checks:
 * - Question text exists
 * - Options array has exactly 4 items
 * - correctIndex is valid (0-3)
 * - All options are non-empty
 * - Options are unique
 */
export function validatePhase1Question(q: unknown, index: number = 0): ValidationResult {
    // Type guard for object
    if (!q || typeof q !== 'object') {
        return { valid: false, errors: [`Question ${index + 1}: Not a valid object`] };
    }

    const question = q as Record<string, unknown>;
    const errors: string[] = [];
    const prefix = `Question ${index + 1}`;

    // Check question text
    if (!question.text && !question.question) {
        errors.push(`${prefix}: Missing question text (no 'text' or 'question' field)`);
    } else {
        const text = question.text || question.question;
        if (typeof text !== 'string' || text.trim().length === 0) {
            errors.push(`${prefix}: Question text is empty`);
        }
    }

    // Check options/answers array
    const options = question.options || question.answers;
    if (!Array.isArray(options)) {
        errors.push(`${prefix}: Missing or invalid options array (no 'options' or 'answers' field)`);
    } else {
        if (options.length !== 4) {
            errors.push(`${prefix}: Expected 4 options, got ${options.length}`);
        }

        // Check each option is non-empty
        options.forEach((opt, i) => {
            if (typeof opt !== 'string' || opt.trim().length === 0) {
                errors.push(`${prefix}: Option ${i + 1} is empty or invalid`);
            }
        });

        // Check for duplicate options
        const uniqueOptions = new Set(options.map((o: unknown) =>
            typeof o === 'string' ? o.toLowerCase().trim() : ''
        ));
        if (uniqueOptions.size !== options.length) {
            errors.push(`${prefix}: Duplicate options detected`);
        }
    }

    // Check correctIndex
    if (question.correctIndex === undefined && question.correct_index === undefined && question.correctAnswer === undefined) {
        errors.push(`${prefix}: Missing correctIndex field`);
    } else {
        const correctIdx = question.correctIndex ?? question.correct_index;
        if (typeof correctIdx !== 'number') {
            errors.push(`${prefix}: correctIndex must be a number, got ${typeof correctIdx}`);
        } else if (correctIdx < 0 || correctIdx > 3) {
            errors.push(`${prefix}: correctIndex must be between 0-3, got ${correctIdx}`);
        }
    }

    return {
        valid: errors.length === 0,
        errors
    };
}

/**
 * Normalize and validate a Phase 1 question
 * Accepts flexible field names (text/question, options/answers, correctIndex/correct_index)
 * Returns a normalized Phase1Question or null if invalid
 */
export function normalizePhase1Question(q: unknown, index: number = 0): Phase1Question | null {
    const validation = validatePhase1Question(q, index);

    if (!validation.valid) {
        console.error(`❌ Invalid Phase 1 question:`, validation.errors);
        return null;
    }

    // Type guard and normalize field names
    const question = q as Record<string, unknown>;
    const text = (question.text || question.question) as string;
    const options = (question.options || question.answers) as string[];
    const correctIndex = (question.correctIndex ?? question.correct_index) as number;
    const anecdote = question.anecdote as string | undefined;

    return {
        text,
        options,
        correctIndex,
        anecdote
    };
}

/**
 * Validate and normalize an array of Phase 1 questions
 * Filters out invalid questions and logs errors
 */
export function normalizePhase1Questions(questions: unknown[]): Phase1Question[] {
    const normalized: Phase1Question[] = [];

    questions.forEach((q, idx) => {
        const normalizedQ = normalizePhase1Question(q, idx);
        if (normalizedQ) {
            normalized.push(normalizedQ);
        } else {
            console.warn(`⚠️ Skipping invalid question at index ${idx}:`, JSON.stringify(q, null, 2));
        }
    });

    return normalized;
}

/**
 * Validate a Phase 4 question (MCQ with 4 options, identical structure to Phase 1)
 */
export function validatePhase4Question(q: unknown, index: number = 0): ValidationResult {
    // Phase 4 has same structure as Phase 1
    return validatePhase1Question(q, index);
}

/**
 * Normalize and validate a Phase 4 question
 */
export function normalizePhase4Question(q: unknown, index: number = 0): Phase4Question | null {
    const validation = validatePhase4Question(q, index);

    if (!validation.valid) {
        console.error(`❌ Invalid Phase 4 question:`, validation.errors);
        return null;
    }

    // Type guard and normalize field names
    const question = q as Record<string, unknown>;
    const text = (question.text || question.question) as string;
    const options = (question.options || question.answers) as string[];
    const correctIndex = (question.correctIndex ?? question.correct_index) as number;
    const anecdote = question.anecdote as string | undefined;

    return {
        text,
        options,
        correctIndex,
        anecdote
    };
}

/**
 * Validate and normalize an array of Phase 4 questions
 */
export function normalizePhase4Questions(questions: unknown[]): Phase4Question[] {
    const normalized: Phase4Question[] = [];

    questions.forEach((q, idx) => {
        const normalizedQ = normalizePhase4Question(q, idx);
        if (normalizedQ) {
            normalized.push(normalizedQ);
        } else {
            console.warn(`⚠️ Skipping invalid Phase 4 question at index ${idx}:`, JSON.stringify(q, null, 2));
        }
    });

    return normalized;
}

/**
 * Validate a Phase 2 item
 */
export function validatePhase2Item(item: unknown, index: number = 0): ValidationResult {
    const errors: string[] = [];
    const prefix = `Item ${index + 1}`;

    // Type guard
    if (!item || typeof item !== 'object') {
        return { valid: false, errors: [`${prefix}: Not a valid object`] };
    }

    const itemObj = item as Record<string, unknown>;

    if (!itemObj.text || typeof itemObj.text !== 'string' || itemObj.text.trim().length === 0) {
        errors.push(`${prefix}: Missing or empty text field`);
    }

    if (!itemObj.answer || !['A', 'B', 'Both'].includes(itemObj.answer as string)) {
        errors.push(`${prefix}: Invalid answer (must be 'A', 'B', or 'Both')`);
    }

    return {
        valid: errors.length === 0,
        errors
    };
}

/**
 * Validate a Phase 2 set
 */
export function validatePhase2Set(set: unknown): ValidationResult {
    const errors: string[] = [];

    // Type guard
    if (!set || typeof set !== 'object') {
        return { valid: false, errors: ['Not a valid object'] };
    }

    const setObj = set as Record<string, unknown>;

    if (!setObj.optionA || typeof setObj.optionA !== 'string') {
        errors.push('Missing or invalid optionA');
    }

    if (!setObj.optionB || typeof setObj.optionB !== 'string') {
        errors.push('Missing or invalid optionB');
    }

    if (!Array.isArray(setObj.items)) {
        errors.push('Missing or invalid items array');
    } else {
        setObj.items.forEach((item: unknown, idx: number) => {
            const itemValidation = validatePhase2Item(item, idx);
            errors.push(...itemValidation.errors);
        });
    }

    return {
        valid: errors.length === 0,
        errors
    };
}

/**
 * Validate a Phase 5 question
 */
export function validatePhase5Question(q: unknown, index: number = 0): ValidationResult {
    const errors: string[] = [];
    const prefix = `Question ${index + 1}`;

    // Type guard
    if (!q || typeof q !== 'object') {
        return { valid: false, errors: [`${prefix}: Not a valid object`] };
    }

    const question = q as Record<string, unknown>;

    if (!question.question || typeof question.question !== 'string' || question.question.trim().length === 0) {
        errors.push(`${prefix}: Missing or empty question field`);
    }

    if (!question.answer || typeof question.answer !== 'string' || question.answer.trim().length === 0) {
        errors.push(`${prefix}: Missing or empty answer field`);
    }

    return {
        valid: errors.length === 0,
        errors
    };
}

/**
 * Validate and normalize an array of Phase 5 questions
 */
export function normalizePhase5Questions(questions: unknown[]): Phase5Question[] {
    const normalized: Phase5Question[] = [];

    questions.forEach((q, idx) => {
        const validation = validatePhase5Question(q, idx);

        if (validation.valid) {
            const question = q as Record<string, unknown>;
            normalized.push({
                question: question.question as string,
                answer: question.answer as string
            });
        } else {
            console.error(`❌ Invalid Phase 5 question:`, validation.errors);
            console.warn(`⚠️ Skipping invalid Phase 5 question at index ${idx}:`, JSON.stringify(q, null, 2));
        }
    });

    return normalized;
}
