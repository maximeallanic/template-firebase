import { httpsCallable } from 'firebase/functions';
import { functions } from './firebase';
import type { GameLanguage } from '../types/languageTypes';

export interface GameGenerationInput {
    phase: 'phase1' | 'phase2' | 'phase3' | 'phase4' | 'phase5';
    topic?: string;
    difficulty?: 'easy' | 'normal' | 'hard' | 'wtf';
    language?: GameLanguage; // Language for AI-generated questions (defaults to 'fr')
    roomCode?: string; // For server-side idempotency check
    soloMode?: boolean; // Bypass premium check for solo practice mode
    // Completion mode: generate only missing questions
    completeCount?: number; // Number of questions to generate (for completion)
    existingQuestions?: unknown[]; // Existing questions to avoid duplicates
}

export interface GameGenerationOutput {
    success: boolean;
    data: Record<string, unknown> | unknown[];
    topic: string; // The topic used (may be AI-generated)
    skipped?: boolean; // True if server returned cached questions (idempotency)
    usage: {
        totalTokens: number;
        estimatedCost: number;
    };
}

/**
 * Call the AI Cloud Function to generate game questions.
 * Validates phase and topic on the server side.
 * Timeout is set to 300 seconds to match the Cloud Function timeout.
 */
export const generateGameQuestions = async (input: GameGenerationInput): Promise<GameGenerationOutput> => {
    // Set timeout to 300 seconds (5 minutes) to match Cloud Function timeout
    // This prevents client-side timeouts before the server has a chance to respond
    const generateFn = httpsCallable<GameGenerationInput, GameGenerationOutput>(
        functions,
        'generateGameQuestions',
        { timeout: 300000 } // 300 seconds in milliseconds
    );
    const startTime = performance.now();

    console.log('[AI-CLIENT] üì§ Calling generateGameQuestions', {
        phase: input.phase,
        topic: input.topic || '(auto)',
        difficulty: input.difficulty || 'normal',
        language: input.language || 'fr',
        roomCode: input.roomCode || '(none)',
        completeCount: input.completeCount || '(full)',
        existingCount: input.existingQuestions?.length || 0,
        timestamp: new Date().toISOString()
    });

    try {
        const result = await generateFn(input);
        const duration = Math.round(performance.now() - startTime);

        console.log('[AI-CLIENT] üì• Response received', {
            success: result.data?.success,
            skipped: result.data?.skipped || false,
            dataType: Array.isArray(result.data?.data) ? 'array' : typeof result.data?.data,
            dataLength: Array.isArray(result.data?.data) ? result.data.data.length : 'N/A',
            topic: result.data?.topic,
            usage: result.data?.usage,
            duration: `${duration}ms`
        });

        if (!result.data?.data) {
            console.warn('[AI-CLIENT] ‚ö†Ô∏è Response has no data!', result);
        }

        return result.data;
    } catch (error) {
        const duration = Math.round(performance.now() - startTime);
        console.error('[AI-CLIENT] ‚ùå Error after', `${duration}ms:`, {
            errorName: (error as Error)?.name,
            errorMessage: (error as Error)?.message,
            errorCode: (error as { code?: string })?.code,
            errorDetails: (error as { details?: unknown })?.details,
            input
        });
        throw error;
    }
};

// Errors that should NOT be retried (server is still running or quota exhausted)
const NON_RETRYABLE_ERRORS = [
    'functions/deadline-exceeded',  // Server is still running, just slow
    'functions/cancelled',          // Request was cancelled
    'functions/resource-exhausted', // Quota exceeded, retry won't help
];

/**
 * Generate game questions with automatic retry on failure.
 * Retries up to 3 times with exponential backoff.
 * Does NOT retry on non-retryable errors (deadline-exceeded, cancelled, resource-exhausted).
 * Topic is generated by AI server-side if not provided.
 */
export const generateWithRetry = async (
    input: GameGenerationInput,
    maxRetries = 3
): Promise<GameGenerationOutput> => {
    let lastError: Error | null = null;
    const retryStartTime = performance.now();

    console.log('[AI-CLIENT] üé≤ generateWithRetry started', {
        phase: input.phase,
        topic: input.topic || '(auto)',
        difficulty: input.difficulty || 'normal',
        roomCode: input.roomCode,
        completeCount: input.completeCount || '(full)',
        existingCount: input.existingQuestions?.length || 0,
        maxRetries,
        timestamp: new Date().toISOString()
    });

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            console.log(`[AI-CLIENT] üîÑ Attempt ${attempt}/${maxRetries}...`);
            const result = await generateGameQuestions(input);

            const totalDuration = Math.round(performance.now() - retryStartTime);
            console.log(`[AI-CLIENT] ‚úÖ Success on attempt ${attempt}/${maxRetries} (total: ${totalDuration}ms)`);

            return result;
        } catch (err) {
            lastError = err as Error;
            const errorCode = (err as { code?: string })?.code;

            console.warn(`[AI-CLIENT] ‚ö†Ô∏è Attempt ${attempt}/${maxRetries} failed:`, {
                errorMessage: lastError.message,
                errorCode
            });

            // Don't retry on non-retryable errors
            if (errorCode && NON_RETRYABLE_ERRORS.includes(errorCode)) {
                const totalDuration = Math.round(performance.now() - retryStartTime);
                console.error(`[AI-CLIENT] ‚ùå Non-retryable error (${errorCode}), stopping retries`, {
                    totalDuration: `${totalDuration}ms`
                });
                throw err; // Propagate immediately without retrying
            }

            if (attempt < maxRetries) {
                const backoffMs = 1000 * attempt;
                console.log(`[AI-CLIENT] ‚è≥ Waiting ${backoffMs}ms before retry...`);
                await new Promise(r => setTimeout(r, backoffMs));
            }
        }
    }

    const totalDuration = Math.round(performance.now() - retryStartTime);
    console.error('[AI-CLIENT] ‚ùå All retries exhausted', {
        attempts: maxRetries,
        totalDuration: `${totalDuration}ms`,
        lastError: lastError?.message
    });

    throw lastError || new Error('G√©n√©ration √©chou√©e apr√®s 3 tentatives');
};

// ============================================================================
// NOTE: Phase 3 and Phase 5 answer validation is now handled server-side
// via the submitAnswer Cloud Function (#72). The deprecated validatePhase3Answer
// and validatePhase5Answers Cloud Functions have been removed.
// ============================================================================
