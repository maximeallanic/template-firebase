import { httpsCallable } from 'firebase/functions';
import { functions } from './firebase';

export interface GameGenerationInput {
    phase: 'phase1' | 'phase2' | 'phase3' | 'phase4' | 'phase5';
    topic?: string;
    difficulty?: 'easy' | 'normal' | 'hard' | 'wtf';
    roomCode?: string; // For server-side idempotency check
}

export interface GameGenerationOutput {
    success: boolean;
    data: Record<string, unknown> | unknown[];
    topic: string; // The topic used (may be AI-generated)
    skipped?: boolean; // True if server returned cached questions (idempotency)
    usage: {
        totalTokens: number;
        estimatedCost: number;
    };
}

/**
 * Call the AI Cloud Function to generate game questions.
 * Validates phase and topic on the server side.
 */
export const generateGameQuestions = async (input: GameGenerationInput): Promise<GameGenerationOutput> => {
    const generateFn = httpsCallable<GameGenerationInput, GameGenerationOutput>(functions, 'generateGameQuestions');
    try {
        const result = await generateFn(input);
        return result.data;
    } catch (error) {
        console.error("AI Client Error:", error);
        throw error;
    }
};

/**
 * Generate game questions with automatic retry on failure.
 * Retries up to 3 times with exponential backoff.
 * Topic is generated by AI server-side if not provided.
 */
export const generateWithRetry = async (
    input: GameGenerationInput,
    maxRetries = 3
): Promise<GameGenerationOutput> => {
    let lastError: Error | null = null;

    console.log(`üé≤ G√©n√©ration ${input.phase}${input.topic ? ` (topic: ${input.topic})` : ' (topic g√©n√©r√© par IA)'}...`);

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            console.log(`Tentative de g√©n√©ration ${attempt}/${maxRetries}...`);
            return await generateGameQuestions(input);
        } catch (err) {
            lastError = err as Error;
            console.warn(`Tentative ${attempt}/${maxRetries} √©chou√©e:`, err);
            if (attempt < maxRetries) {
                // Exponential backoff: 1s, 2s, 3s...
                await new Promise(r => setTimeout(r, 1000 * attempt));
            }
        }
    }

    throw lastError || new Error('G√©n√©ration √©chou√©e apr√®s 3 tentatives');
};
