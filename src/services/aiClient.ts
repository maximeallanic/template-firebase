import { httpsCallable } from 'firebase/functions';
import { functions } from './firebase';

export interface GameGenerationInput {
    phase: 'phase1' | 'phase2' | 'phase3' | 'phase4' | 'phase5';
    topic?: string;
    difficulty?: 'easy' | 'normal' | 'hard' | 'wtf';
    roomCode?: string; // For server-side idempotency check
    soloMode?: boolean; // Bypass premium check for solo practice mode
    // Completion mode: generate only missing questions
    completeCount?: number; // Number of questions to generate (for completion)
    existingQuestions?: unknown[]; // Existing questions to avoid duplicates
}

export interface GameGenerationOutput {
    success: boolean;
    data: Record<string, unknown> | unknown[];
    topic: string; // The topic used (may be AI-generated)
    skipped?: boolean; // True if server returned cached questions (idempotency)
    usage: {
        totalTokens: number;
        estimatedCost: number;
    };
}

/**
 * Call the AI Cloud Function to generate game questions.
 * Validates phase and topic on the server side.
 * Timeout is set to 300 seconds to match the Cloud Function timeout.
 */
export const generateGameQuestions = async (input: GameGenerationInput): Promise<GameGenerationOutput> => {
    // Set timeout to 300 seconds (5 minutes) to match Cloud Function timeout
    // This prevents client-side timeouts before the server has a chance to respond
    const generateFn = httpsCallable<GameGenerationInput, GameGenerationOutput>(
        functions,
        'generateGameQuestions',
        { timeout: 300000 } // 300 seconds in milliseconds
    );
    const startTime = performance.now();

    console.log('[AI-CLIENT] üì§ Calling generateGameQuestions', {
        phase: input.phase,
        topic: input.topic || '(auto)',
        difficulty: input.difficulty || 'normal',
        roomCode: input.roomCode || '(none)',
        completeCount: input.completeCount || '(full)',
        existingCount: input.existingQuestions?.length || 0,
        timestamp: new Date().toISOString()
    });

    try {
        const result = await generateFn(input);
        const duration = Math.round(performance.now() - startTime);

        console.log('[AI-CLIENT] üì• Response received', {
            success: result.data?.success,
            skipped: result.data?.skipped || false,
            dataType: Array.isArray(result.data?.data) ? 'array' : typeof result.data?.data,
            dataLength: Array.isArray(result.data?.data) ? result.data.data.length : 'N/A',
            topic: result.data?.topic,
            usage: result.data?.usage,
            duration: `${duration}ms`
        });

        if (!result.data?.data) {
            console.warn('[AI-CLIENT] ‚ö†Ô∏è Response has no data!', result);
        }

        return result.data;
    } catch (error) {
        const duration = Math.round(performance.now() - startTime);
        console.error('[AI-CLIENT] ‚ùå Error after', `${duration}ms:`, {
            errorName: (error as Error)?.name,
            errorMessage: (error as Error)?.message,
            errorCode: (error as { code?: string })?.code,
            errorDetails: (error as { details?: unknown })?.details,
            input
        });
        throw error;
    }
};

// Errors that should NOT be retried (server is still running or quota exhausted)
const NON_RETRYABLE_ERRORS = [
    'functions/deadline-exceeded',  // Server is still running, just slow
    'functions/cancelled',          // Request was cancelled
    'functions/resource-exhausted', // Quota exceeded, retry won't help
];

/**
 * Generate game questions with automatic retry on failure.
 * Retries up to 3 times with exponential backoff.
 * Does NOT retry on non-retryable errors (deadline-exceeded, cancelled, resource-exhausted).
 * Topic is generated by AI server-side if not provided.
 */
export const generateWithRetry = async (
    input: GameGenerationInput,
    maxRetries = 3
): Promise<GameGenerationOutput> => {
    let lastError: Error | null = null;
    const retryStartTime = performance.now();

    console.log('[AI-CLIENT] üé≤ generateWithRetry started', {
        phase: input.phase,
        topic: input.topic || '(auto)',
        difficulty: input.difficulty || 'normal',
        roomCode: input.roomCode,
        completeCount: input.completeCount || '(full)',
        existingCount: input.existingQuestions?.length || 0,
        maxRetries,
        timestamp: new Date().toISOString()
    });

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            console.log(`[AI-CLIENT] üîÑ Attempt ${attempt}/${maxRetries}...`);
            const result = await generateGameQuestions(input);

            const totalDuration = Math.round(performance.now() - retryStartTime);
            console.log(`[AI-CLIENT] ‚úÖ Success on attempt ${attempt}/${maxRetries} (total: ${totalDuration}ms)`);

            return result;
        } catch (err) {
            lastError = err as Error;
            const errorCode = (err as { code?: string })?.code;

            console.warn(`[AI-CLIENT] ‚ö†Ô∏è Attempt ${attempt}/${maxRetries} failed:`, {
                errorMessage: lastError.message,
                errorCode
            });

            // Don't retry on non-retryable errors
            if (errorCode && NON_RETRYABLE_ERRORS.includes(errorCode)) {
                const totalDuration = Math.round(performance.now() - retryStartTime);
                console.error(`[AI-CLIENT] ‚ùå Non-retryable error (${errorCode}), stopping retries`, {
                    totalDuration: `${totalDuration}ms`
                });
                throw err; // Propagate immediately without retrying
            }

            if (attempt < maxRetries) {
                const backoffMs = 1000 * attempt;
                console.log(`[AI-CLIENT] ‚è≥ Waiting ${backoffMs}ms before retry...`);
                await new Promise(r => setTimeout(r, backoffMs));
            }
        }
    }

    const totalDuration = Math.round(performance.now() - retryStartTime);
    console.error('[AI-CLIENT] ‚ùå All retries exhausted', {
        attempts: maxRetries,
        totalDuration: `${totalDuration}ms`,
        lastError: lastError?.message
    });

    throw lastError || new Error('G√©n√©ration √©chou√©e apr√®s 3 tentatives');
};

// ============================================================================
// Phase 3 Answer Validation
// ============================================================================

export interface AnswerValidationInput {
    playerAnswer: string;
    correctAnswer: string;
    acceptableAnswers?: string[];
}

export interface AnswerValidationOutput {
    isCorrect: boolean;
    confidence: number;
    matchType: 'exact' | 'alternative' | 'llm' | 'rejected';
    explanation?: string;
}

/**
 * Validate a player's answer against the correct answer using LLM.
 * Uses fast path for exact matches, LLM for fuzzy matching.
 * Timeout is set to 30 seconds to match the Cloud Function timeout.
 */
export const validatePhase3Answer = async (input: AnswerValidationInput): Promise<AnswerValidationOutput> => {
    const validateFn = httpsCallable<AnswerValidationInput, AnswerValidationOutput>(
        functions,
        'validatePhase3Answer',
        { timeout: 30000 } // 30 seconds
    );

    console.log('[AI-CLIENT] üîç Validating answer', {
        playerAnswer: input.playerAnswer,
        correctAnswer: input.correctAnswer,
        hasAlternatives: !!input.acceptableAnswers?.length,
    });

    try {
        const result = await validateFn(input);

        console.log('[AI-CLIENT] ‚úÖ Validation result', {
            isCorrect: result.data.isCorrect,
            confidence: result.data.confidence,
            matchType: result.data.matchType,
        });

        return result.data;
    } catch (error) {
        console.error('[AI-CLIENT] ‚ùå Validation error:', error);
        throw error;
    }
};

// ============================================================================
// Phase 5 Bulk Answer Validation
// ============================================================================

export interface Phase5Question {
    question: string;
    answer: string;
    acceptableAnswers?: string[];
}

export interface Phase5ValidationInput {
    questions: Phase5Question[];
    spicyAnswers: string[];
    sweetAnswers: string[];
}

export interface Phase5ValidationResult {
    index: number;
    expected: string;
    given: string;
    isCorrect: boolean;
    explanation?: string;
}

export interface Phase5TeamResult {
    answers: Phase5ValidationResult[];
    first5Correct: boolean;
    all10Correct: boolean;
    points: number;
}

export interface Phase5ValidationOutput {
    spicy: Phase5TeamResult;
    sweet: Phase5TeamResult;
}

/**
 * Validate all Phase 5 answers for both teams using LLM.
 * Returns scoring: +5 for first 5 correct in order, +10 for all 10 correct, 0 otherwise.
 * Timeout is set to 120 seconds to match the Cloud Function timeout.
 */
export const validatePhase5Answers = async (input: Phase5ValidationInput): Promise<Phase5ValidationOutput> => {
    const validateFn = httpsCallable<Phase5ValidationInput, Phase5ValidationOutput>(
        functions,
        'validatePhase5Answers',
        { timeout: 120000 } // 120 seconds
    );

    console.log('[AI-CLIENT] üîç Validating Phase 5 answers', {
        questionsCount: input.questions.length,
        spicyAnswersCount: input.spicyAnswers.length,
        sweetAnswersCount: input.sweetAnswers.length,
    });

    try {
        const result = await validateFn(input);

        console.log('[AI-CLIENT] ‚úÖ Phase 5 validation result', {
            spicyPoints: result.data.spicy.points,
            spicy5_5: result.data.spicy.first5Correct,
            spicy10_10: result.data.spicy.all10Correct,
            sweetPoints: result.data.sweet.points,
            sweet5_5: result.data.sweet.first5Correct,
            sweet10_10: result.data.sweet.all10Correct,
        });

        return result.data;
    } catch (error) {
        console.error('[AI-CLIENT] ‚ùå Phase 5 validation error:', error);
        throw error;
    }
};
