{
  "rules": {
    "gameData": {
      // SEC-011: Game answers stored server-side only
      // CRITICAL: This node contains correct answers for all phases
      // Clients MUST NOT be able to read this data - only CF can read
      // Exception: Solo mode - user can write to their own gameData/{uid}/ node
      "$roomId": {
        // Only owner can write their own solo session data (roomId = uid in solo mode)
        // Read is always false (clients never read game data, only CF does)
        ".read": false,
        ".write": "auth != null && auth.uid == $roomId"
      }
    },
    "soloSessions": {
      "$odId": {
        // Solo sessions: only the owner can read their own session
        // Write is blocked - only Cloud Functions can write
        ".read": "auth != null && auth.uid == $odId",
        ".write": false
      }
    },
    "rooms": {
      "$roomId": {
        // Authenticated users can read rooms they're part of, or any room (to join)
        ".read": "auth != null",
        // Write allowed if: creating new room OR user is host OR user is a player in the room
        ".write": "auth != null && (
          !data.exists() ||
          data.child('hostId').val() == auth.uid ||
          data.child('players').child(auth.uid).exists()
        )",
        "players": {
          "$playerId": {
            ".validate": "newData.hasChildren(['id', 'name', 'avatar', 'isHost', 'score', 'joinedAt', 'isOnline'])",
            // Host can write anything, player can only CREATE their own node (not update it at this level)
            ".write": "auth != null && (data.parent().parent().child('hostId').val() == auth.uid || ($playerId == auth.uid && !data.exists()))",
            // Individual field rules for players (not host)
            "name": {
              ".write": "auth != null && $playerId == auth.uid"
            },
            "avatar": {
              ".write": "auth != null && $playerId == auth.uid"
            },
            "isOnline": {
              ".write": "auth != null && $playerId == auth.uid"
            },
            "team": {
              // Only host can assign teams
              ".write": "auth != null && data.parent().parent().parent().child('hostId').val() == auth.uid"
            },
            "score": {
              // SECURITY: Only host can modify scores - prevents cheating
              ".write": "auth != null && data.parent().parent().parent().child('hostId').val() == auth.uid"
            },
            "id": {
              ".write": "auth != null && $playerId == auth.uid"
            },
            "isHost": {
              // Only set once during room creation
              ".write": "auth != null && !data.exists()"
            },
            "joinedAt": {
              // Only set once when joining
              ".write": "auth != null && !data.exists()"
            }
          }
        },
        "state": {
          ".validate": "newData.hasChild('status') && newData.hasChild('phaseState')",
          // Only host can modify game state (except playersReady and phase answer nodes)
          ".write": "auth != null && data.parent().child('hostId').val() == auth.uid",
          "playersReady": {
            "$playerId": {
              // Each player can mark themselves as ready (if they're in the room)
              ".write": "auth != null && $playerId == auth.uid && root.child('rooms').child($roomId).child('players').child(auth.uid).exists()",
              ".validate": "newData.isBoolean()"
            }
          },
          // Phase answer nodes - readable by all players, written by Cloud Functions (Admin SDK)
          "phase1Answers": {
            ".read": "auth != null && root.child('rooms').child($roomId).child('players').child(auth.uid).exists()"
          },
          "phase2Answers": {
            ".read": "auth != null && root.child('rooms').child($roomId).child('players').child(auth.uid).exists()"
          },
          "phase3Answers": {
            ".read": "auth != null && root.child('rooms').child($roomId).child('players').child(auth.uid).exists()"
          },
          "phase4Answers": {
            ".read": "auth != null && root.child('rooms').child($roomId).child('players').child(auth.uid).exists()"
          },
          "phase4Buzz": {
            // Players can write their buzz (first one wins in RTDB)
            ".read": "auth != null && root.child('rooms').child($roomId).child('players').child(auth.uid).exists()",
            "$questionIndex": {
              ".write": "auth != null && root.child('rooms').child($roomId).child('players').child(auth.uid).exists() && !data.exists()",
              ".validate": "newData.hasChildren(['odId', 'team', 'timestamp'])"
            }
          },
          "phase5Answers": {
            ".read": "auth != null && root.child('rooms').child($roomId).child('players').child(auth.uid).exists()"
          }
        },
        "hostId": {
          // Host ID can only be set on room creation, cannot be changed
          ".write": "auth != null && !data.exists()"
        }
      }
    },
    "userHistory": {
      "$playerId": {
        // SEC-006: Only owner can read and write their own history
        ".read": "auth != null && auth.uid == $playerId",
        ".write": "auth != null && auth.uid == $playerId"
      }
    },
    "cursors": {
      "$roomCode": {
        // SEC-007: Only players in this room can read cursors
        ".read": "auth != null && root.child('rooms').child($roomCode).child('players').child(auth.uid).exists()",
        "$playerId": {
          // Only the owner can write their own cursor position (if they're in the room)
          ".write": "auth != null && auth.uid == $playerId && root.child('rooms').child($roomCode).child('players').child(auth.uid).exists()",
          ".validate": "newData.hasChildren(['x', 'y', 'isTouch', 'timestamp'])"
        }
      }
    },
    ".read": false,
    ".write": false
  }
}
